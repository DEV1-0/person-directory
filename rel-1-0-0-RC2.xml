<?xml version="1.0" encoding="iso-8859-1" standalone="no"?>
<!-- Generated by the JDiff Javadoc doclet -->
<!-- (http://www.jdiff.org) -->
<!-- on Thu Mar 30 17:02:52 EST 2006 -->

<api
  xmlns:xsi='C:\Documents and Settings\dalquist\.maven\cache\maven-jdiff-plugin-1.4/2001/XMLSchema-instance'
  xsi:noNamespaceSchemaLocation='api.xsd'
  name="rel-1-0-0-RC2"
  jdversion="1.0.9">

<!--  Command line arguments =  -doclet jdiff.JDiff -docletpath C:\ASF\Maven_1.0.2\lib\ant-1.5.3-1.jar;C:\ASF\Maven_1.0.2\lib\ant-optional-1.5.3-1.jar;C:\ASF\Maven_1.0.2\lib\commons-beanutils-1.6.1.jar;C:\ASF\Maven_1.0.2\lib\commons-betwixt-1.0-beta-1.20030111.103454.jar;C:\ASF\Maven_1.0.2\lib\commons-cli-1.0-beta-2.jar;C:\ASF\Maven_1.0.2\lib\commons-collections-2.1.jar;C:\ASF\Maven_1.0.2\lib\commons-digester-1.4.1.jar;C:\ASF\Maven_1.0.2\lib\commons-grant-1.0-beta-4.jar;C:\ASF\Maven_1.0.2\lib\commons-graph-0.8.1.jar;C:\ASF\Maven_1.0.2\lib\commons-httpclient-2.0.jar;C:\ASF\Maven_1.0.2\lib\commons-io-20030203.000550.jar;C:\ASF\Maven_1.0.2\lib\commons-jelly-20030902.160215.jar;C:\ASF\Maven_1.0.2\lib\commons-jelly-tags-ant-1.0.jar;C:\ASF\Maven_1.0.2\lib\commons-jelly-tags-define-20030211.142932.jar;C:\ASF\Maven_1.0.2\lib\commons-jelly-tags-util-20030211.141939.jar;C:\ASF\Maven_1.0.2\lib\commons-jelly-tags-xml-20040613.030723.jar;C:\ASF\Maven_1.0.2\lib\commons-jexl-1.0-beta-1.jar;C:\ASF\Maven_1.0.2\lib\commons-lang-2.0.jar;C:\ASF\Maven_1.0.2\lib\commons-logging-1.0.3.jar;C:\ASF\Maven_1.0.2\lib\dom4j-1.4-dev-8.jar;C:\ASF\Maven_1.0.2\lib\endorsed\xerces-2.4.0.jar;C:\ASF\Maven_1.0.2\lib\endorsed\xml-apis-1.0.b2.jar;C:\ASF\Maven_1.0.2\lib\forehead-1.0-beta-5.jar;C:\ASF\Maven_1.0.2\lib\log4j-1.2.8.jar;C:\ASF\Maven_1.0.2\lib\maven-jelly-tags-1.0.1.jar;C:\ASF\Maven_1.0.2\lib\maven.jar;C:\ASF\Maven_1.0.2\lib\plexus-0.6.jar;C:\ASF\Maven_1.0.2\lib\werkz-20040426.222000.jar;C:\ASF\Maven_1.0.2\lib\which-1.0.jar;C:\Documents and Settings\dalquist\.maven\repository\jdiff\jars\jdiff-1.0.9.jar -classpath C:\ASF\Maven_1.0.2\lib\forehead-1.0-beta-5.jar -sourcepath C:\JavaClasses\workspace\PersonDirectory\target\jdiff\rel-1-0-0-RC2\PersonDirectory\main\src\java -apiname rel-1-0-0-RC2 -baseURI C:\Documents and Settings\dalquist\.maven\cache\maven-jdiff-plugin-1.4 -->
<package name="org.jasig.portal.services.persondir">
  <!-- start interface org.jasig.portal.services.persondir.IPersonAttributeDao -->
  <interface name="IPersonAttributeDao"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="getUserAttributes" return="java.util.Map"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="seed" type="java.util.Map"/>
      <doc>
      <![CDATA[Obtains a mutable {@link Map} from attribute names to values for
 the given query seed which is an immutable Map. The values may be mutable objects but it is
 recommended that they be immutable.<br>
 
 For the returned {@link Map}; Keys must be {@link String}, Values
 can be any {@link Object}, they are typically {@link String}s.<br>
 
 Values may also be multi-valued, in this case they are of type
 {@link java.util.List} and the list contents are the values of the
 attribute.<br>
 
 This method returns according to the following rules:<br>
 <ul>
  <li>If the user exists and has attributes a populated {@link Map} is returned.</li>
  <li>If the user exists and has no attributes an empty {@link Map} is returned.</li>
  <li>If the user doesn't exist <code>null</code> is returned.</li>
  <li>If an error occurs while getting the attributes the appropriate exception will be propagated.</li>
 </ul>
 <br>
 Unless otherwise specified by an implementation the returned {@link Map}
 will not be a union of the seed and query results. If your are given a
 {@link Map} that includes the attribute "phone" and value "555-1212" and
 the returned {@link Map} contains the attribute "phone" with the value
 "555-1212", this means that your implementation also believes that the
 "phone" attribute should have this value.
 
 @param seed immutable Map of attributes to values to seed the query
 @return Map from attribute names to values
 @throws IllegalArgumentException If <code>seed</code> is <code>null.</code>]]>
      </doc>
    </method>
    <method name="getUserAttributes" return="java.util.Map"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="uid" type="java.lang.String"/>
      <doc>
      <![CDATA[This method uses a single attribute to get a {@link Map} of user
 attributes. 
 <br>
 This methods follows the same return rules as {@link #getUserAttributes(Map)}
 
 @param uid The string to use as the value in the seed
 @return Map from attribute names to values
 @see #getUserAttributes(Map)]]>
      </doc>
    </method>
    <method name="getPossibleUserAttributeNames" return="java.util.Set"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Gets a {@link Set} of attribute names that may be returned by the
 {@link #getUserAttributes(Map)}. The names returned represent all
 possible names {@link #getUserAttributes(Map)} could return. If the
 dao doesn't have a way to know all possible attribute names this
 method should return <code>null</code>.
 <br>
 Returns an immutable {@link Set}.
 
 @return A {link Set} of possible attribute names for user queries.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Data access object which, for a given {@link Map} of query
 data, returns a {@link Map} from attribute names to attribute
 values.
 
 @author andrew.petro@yale.edu
 @author Eric Dalquist <a href="mailto:edalquist@unicon.net">edalquist@unicon.net</a>
 @version $Revision$ $Date$
 @since uPortal 2.5]]>
    </doc>
  </interface>
  <!-- end interface org.jasig.portal.services.persondir.IPersonAttributeDao -->
</package>
<package name="org.jasig.portal.services.persondir.support">
  <!-- start class org.jasig.portal.services.persondir.support.AbstractAggregatingDefaultQueryPersonAttributeDao -->
  <class name="AbstractAggregatingDefaultQueryPersonAttributeDao" extends="org.jasig.portal.services.persondir.support.AbstractDefaultAttributePersonAttributeDao"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="AbstractAggregatingDefaultQueryPersonAttributeDao"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getUserAttributes" return="java.util.Map"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="seed" type="java.util.Map"/>
      <doc>
      <![CDATA[Iterates through the configured {@link java.util.List} of {@link IPersonAttributeDao}
 instances. The results from each DAO are merged into the result {@link Map}
 by the configured {@link org.jasig.portal.services.persondir.support.merger.IAttributeMerger}. 
 
 @see org.jasig.portal.services.persondir.IPersonAttributeDao#getUserAttributes(java.util.Map)]]>
      </doc>
    </method>
    <method name="getAttributesFromDao" return="java.util.Map"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="seed" type="java.util.Map"/>
      <param name="isFirstQuery" type="boolean"/>
      <param name="currentlyConsidering" type="org.jasig.portal.services.persondir.IPersonAttributeDao"/>
      <param name="resultAttributes" type="java.util.Map"/>
      <doc>
      <![CDATA[Call to execute the appropriate query on the current {@link IPersonAttributeDao}. Provides extra information
 beyond the seed for the state of the query chain and previous results.
 
 @param seed The seed for the original query.
 @param isFirstQuery If this is the first query, this will stay true until a call to this method returns (does not throw an exception).
 @param currentlyConsidering The IPersonAttributeDao to execute the query on.
 @param resultAttributes The Map of results from all previous queries, may be null.
 @return The results from the call to the DAO, follows the same rules as {@link IPersonAttributeDao#getUserAttributes(Map)}.]]>
      </doc>
    </method>
    <method name="getPossibleUserAttributeNames" return="java.util.Set"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[This implementation is not always correct.
 It handles the basic case where the Set of attributes returned by this
 implementation is the union of the attributes declared by all of the
 underlying implementations to be merged.  Of course, an IAttributeMerger
 might provide for a merging policy such that the attributes resulting from
 invoking this IPersonAttributeDao implementation are not the union
 of the attributes declared by the underlying PersonAttributeDaos.
 
 @see org.jasig.portal.services.persondir.IPersonAttributeDao#getPossibleUserAttributeNames()]]>
      </doc>
    </method>
    <method name="getMerger" return="org.jasig.portal.services.persondir.support.merger.IAttributeMerger"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the strategy whereby we accumulate attributes.
 
 @return Returns the attrMerger.]]>
      </doc>
    </method>
    <method name="setMerger"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="merger" type="org.jasig.portal.services.persondir.support.merger.IAttributeMerger"/>
      <doc>
      <![CDATA[Set the strategy whereby we accumulate attributes from the results of 
 polling our delegates.
 
 @param merger The attrMerger to set.
 @throws IllegalArgumentException If merger is <code>null</code>.]]>
      </doc>
    </method>
    <method name="getPersonAttributeDaos" return="java.util.List"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get an unmodifiable {@link List} of delegates which we will poll for attributes.
 
 @return Returns the personAttributeDaos.]]>
      </doc>
    </method>
    <method name="setPersonAttributeDaos"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="daos" type="java.util.List"/>
      <doc>
      <![CDATA[Set the {@link List} of delegates which we will poll for attributes.
 
 @param daos The personAttributeDaos to set.
 @throws IllegalArgumentException If daos is <code>null</code>.]]>
      </doc>
    </method>
    <method name="isRecoverExceptions" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[True if this class will catch exceptions thrown by its delegate DAOs
 and fail to propogate them.  False if this class will stop on failure.
 
 @return true if will recover exceptions, false otherwise]]>
      </doc>
    </method>
    <method name="setRecoverExceptions"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="recover" type="boolean"/>
      <doc>
      <![CDATA[Set to true if you would like this class to swallow RuntimeExceptions
 thrown by its delegates.  This allows it to recover if a particular attribute
 source fails, still considering previous and subsequent sources.
 Set to false if you would like this class to fail hard upon any Throwable
 thrown by its children.  This is desirable in cases where your Portal will not
 function without attributes from all of its sources.
 
 @param recover whether you would like exceptions recovered internally]]>
      </doc>
    </method>
    <field name="personAttributeDaos" type="java.util.List"
      transient="false" volatile="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A List of child IPersonAttributeDao instances which we will poll in order.]]>
      </doc>
    </field>
    <field name="attrMerger" type="org.jasig.portal.services.persondir.support.merger.IAttributeMerger"
      transient="false" volatile="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Strategy for merging together the results from successive PersonAttributeDaos.]]>
      </doc>
    </field>
    <field name="recoverExceptions" type="boolean"
      transient="false" volatile="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[True if we should catch, log, and ignore Throwables propogated by
 individual DAOs.]]>
      </doc>
    </field>
    <doc>
    <![CDATA[Provides a base set of implementations and properties for IPersonAttributeDao
 implementations that aggregate results from a sub List of IPersonAttributeDaos.
 
 @author Eric Dalquist <a href="mailto:edalquist@unicon.net">edalquist@unicon.net</a>
 @version $Revision$]]>
    </doc>
  </class>
  <!-- end class org.jasig.portal.services.persondir.support.AbstractAggregatingDefaultQueryPersonAttributeDao -->
  <!-- start class org.jasig.portal.services.persondir.support.AbstractDefaultAttributePersonAttributeDao -->
  <class name="AbstractDefaultAttributePersonAttributeDao" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.jasig.portal.services.persondir.IPersonAttributeDao"/>
    <constructor name="AbstractDefaultAttributePersonAttributeDao"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getUserAttributes" return="java.util.Map"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="uid" type="java.lang.String"/>
      <doc>
      <![CDATA[Implements this interface method by creating a seed Map from the
 uid argument and delegating to getUserAttributes() on that Map.
 
 Uses {@link Collections#singletonMap(java.lang.Object, java.lang.Object)}
 to create a seed with the value rerturned by 
 {@link #getDefaultAttributeName()} as the key and <code>uid</code>
 as the value. Returns the result of invoking
 {@link IPersonAttributeDao#getUserAttributes(Map)} with the new
  {@link Map} as the argument.
 
 @see org.jasig.portal.services.persondir.IPersonAttributeDao#getUserAttributes(java.lang.String)]]>
      </doc>
    </method>
    <method name="getDefaultAttributeName" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the attribute set by {@link #setDefaultAttributeName(String)} or
 if it has not been called the default value "uid" is returned.
 
 @return The default single string query attribute, will never be null.]]>
      </doc>
    </method>
    <method name="setDefaultAttributeName"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <doc>
      <![CDATA[Sets the attribute to use for {@link #getUserAttributes(String)} queries.
 It cannot be <code>null</code>.
 
 @param name The attribute name to set as default.
 @throws IllegalArgumentException if <code>name</code> is <code>null</code>.]]>
      </doc>
    </method>
    <field name="log" type="Log"
      transient="false" volatile="false"
      static="false" final="true" visibility="protected"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[Abstract class implementing the IPersonAttributeDao method 
 {@link IPersonAttributeDao#getUserAttributes(String)} by delegation to 
 {@link IPersonAttributeDao#getUserAttributes(Map)} using a configurable
 default attribute name.
 
 @author Eric Dalquist <a href="mailto:edalquist@unicon.net">edalquist@unicon.net</a>
 @version $Revision$ $Date$
 @since uPortal 2.5]]>
    </doc>
  </class>
  <!-- end class org.jasig.portal.services.persondir.support.AbstractDefaultAttributePersonAttributeDao -->
  <!-- start class org.jasig.portal.services.persondir.support.AbstractJdbcPersonAttributeDao -->
  <class name="AbstractJdbcPersonAttributeDao" extends="org.jasig.portal.services.persondir.support.AbstractQueryPersonAttributeDao"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="AbstractJdbcPersonAttributeDao" type="javax.sql.DataSource, java.util.List, java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Create the DAO, configured with the needed query information.

 @param ds The {@link DataSource} to run the queries against.
 @param attrList The list of arguments for the query.
 @param sql The SQL query to run.]]>
      </doc>
    </constructor>
    <method name="parseAttributeMapFromResults" return="java.util.Map"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="queryResults" type="java.util.List"/>
      <doc>
      <![CDATA[Takes the {@link List} from the {@link AbstractPersonAttributeMappingQuery} implementation
 and passes it to the implementing the class for parsing into the returned user attribute Map.
 
 @param queryResults Results from the query done using the {@link AbstractPersonAttributeMappingQuery} returned by {@link #getAttributeQuery()}
 @return The results of the query, as specified by {@link org.jasig.portal.services.persondir.IPersonAttributeDao#getUserAttributes(Map)}]]>
      </doc>
    </method>
    <method name="getAttributeQuery" return="org.jasig.portal.services.persondir.support.AbstractJdbcPersonAttributeDao.AbstractPersonAttributeMappingQuery"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return The subclasses implementation of the {@link AbstractPersonAttributeMappingQuery}.]]>
      </doc>
    </method>
    <method name="getUserAttributesIfNeeded" return="java.util.Map"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="args" type="java.lang.Object[]"/>
      <doc>
      <![CDATA[Gets the query from the {@link #getAttributeQuery()} method.<br>
 Runs the query.<br>
 Calls {@link #parseAttributeMapFromResults(List)} with the query results.<br>
 Returns results from {@link #parseAttributeMapFromResults(List)} link.<br>

 @see org.jasig.portal.services.persondir.support.AbstractQueryPersonAttributeDao#getUserAttributesIfNeeded(java.lang.Object[])]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Provides basic implementations for configuring query attributes, ensuring queries have the needed
 attributes to execute, run the query via an abstract MappingSqlQuery stub.
 
 @author Eric Dalquist <a href="mailto:eric.dalquist@doit.wisc.edu">eric.dalquist@doit.wisc.edu</a>
 @version $Revision$]]>
    </doc>
  </class>
  <!-- end class org.jasig.portal.services.persondir.support.AbstractJdbcPersonAttributeDao -->
  <!-- start class org.jasig.portal.services.persondir.support.AbstractJdbcPersonAttributeDao.AbstractPersonAttributeMappingQuery -->
  <class name="AbstractJdbcPersonAttributeDao.AbstractPersonAttributeMappingQuery" extends="MappingSqlQuery"
    abstract="true"
    static="false" final="false" visibility="protected"
    deprecated="not deprecated">
    <constructor name="AbstractJdbcPersonAttributeDao.AbstractPersonAttributeMappingQuery" type="javax.sql.DataSource, java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Instantiate the query, providing a DataSource against which the query
 will run and the SQL representing the query, which should take exactly
 one parameter: the unique ID of the user.
 
 @param ds The data source to use for running the query against.
 @param sql The SQL to run against the data source.]]>
      </doc>
    </constructor>
    <doc>
    <![CDATA[An object which will execute a SQL query with the expectation
 of yielding a ResultSet with zero or one rows, which it maps
 to null or to a Map from uPortal attribute names to values.]]>
    </doc>
  </class>
  <!-- end class org.jasig.portal.services.persondir.support.AbstractJdbcPersonAttributeDao.AbstractPersonAttributeMappingQuery -->
  <!-- start class org.jasig.portal.services.persondir.support.AbstractQueryPersonAttributeDao -->
  <class name="AbstractQueryPersonAttributeDao" extends="org.jasig.portal.services.persondir.support.AbstractDefaultAttributePersonAttributeDao"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="AbstractQueryPersonAttributeDao"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getUserAttributes" return="java.util.Map"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="seed" type="java.util.Map"/>
      <doc>
      <![CDATA[Checks the seed for being null, throws IllegalArgumentException if it is.<br>
 Ensures the seed contains the attributes needed to run the query, returns null if they aren't available.<br>
 Compiles the Object[] of arguments from the seed based on the queryAttributes.<br>

 @see org.jasig.portal.services.persondir.IPersonAttributeDao#getUserAttributes(java.util.Map)]]>
      </doc>
    </method>
    <method name="getUserAttributesIfNeeded" return="java.util.Map"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="args" type="java.lang.Object[]"/>
      <doc>
      <![CDATA[Is called by {@link #getUserAttributes(Map)} if the attributes required for the query, as defined
 by the values of the queryAttributes property, are available in the seed. The implementation of
 {@link #getUserAttributes(Map)} also compiles the array of query argument values based on the order
 of items in the queryAttributes property and the values in the seed.
 
 @param args The arguments to execute the query with.
 @return The results of the query, as specified by {@link org.jasig.portal.services.persondir.IPersonAttributeDao#getUserAttributes(Map)}]]>
      </doc>
    </method>
    <method name="getQueryAttributes" return="java.util.List"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return Returns the queryAttributes.]]>
      </doc>
    </method>
    <method name="setQueryAttributes"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="queryAttributes" type="java.util.List"/>
      <doc>
      <![CDATA[@param queryAttributes The queryAttributes to set.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Provides common functionality for DAOs using a set of attribute values from the seed to
 perform a query. Ensures the nessesary attributes to run the query exist on the seed and
 organizes the values into an argument array.
 
 @author Eric Dalquist <a href="mailto:eric.dalquist@doit.wisc.edu">eric.dalquist@doit.wisc.edu</a>
 @version $Revision$]]>
    </doc>
  </class>
  <!-- end class org.jasig.portal.services.persondir.support.AbstractQueryPersonAttributeDao -->
  <!-- start class org.jasig.portal.services.persondir.support.CachingPersonAttributeDaoImpl -->
  <class name="CachingPersonAttributeDaoImpl" extends="org.jasig.portal.services.persondir.support.AbstractDefaultAttributePersonAttributeDao"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="CachingPersonAttributeDaoImpl"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getCachedPersonAttributesDao" return="org.jasig.portal.services.persondir.IPersonAttributeDao"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return Returns the cachedPersonAttributesDao.]]>
      </doc>
    </method>
    <method name="setCachedPersonAttributesDao"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="cachedPersonAttributesDao" type="org.jasig.portal.services.persondir.IPersonAttributeDao"/>
      <doc>
      <![CDATA[@param cachedPersonAttributesDao The cachedPersonAttributesDao to set.]]>
      </doc>
    </method>
    <method name="getCacheKeyAttributes" return="java.util.Set"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return Returns the cacheKeyAttributes.]]>
      </doc>
    </method>
    <method name="setCacheKeyAttributes"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="cacheKeyAttributes" type="java.util.Set"/>
      <doc>
      <![CDATA[@param cacheKeyAttributes The cacheKeyAttributes to set.]]>
      </doc>
    </method>
    <method name="getUserInfoCache" return="java.util.Map"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return Returns the userInfoCache.]]>
      </doc>
    </method>
    <method name="setUserInfoCache"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="userInfoCache" type="java.util.Map"/>
      <doc>
      <![CDATA[@param userInfoCache The userInfoCache to set.]]>
      </doc>
    </method>
    <method name="getMisses" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return Returns the number of cache misses.]]>
      </doc>
    </method>
    <method name="getQueries" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return Returns the number of queries.]]>
      </doc>
    </method>
    <method name="getUserAttributes" return="java.util.Map"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="seed" type="java.util.Map"/>
      <doc>
      <![CDATA[Wraps the call to the specified cachedPersonAttributesDao IPersonAttributeDao delegate with
 a caching layer. Results are cached using keys generated by {@link #getCacheKey(Map)}.
 
 @see org.jasig.portal.services.persondir.IPersonAttributeDao#getUserAttributes(java.util.Map)]]>
      </doc>
    </method>
    <method name="getPossibleUserAttributeNames" return="java.util.Set"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@see org.jasig.portal.services.persondir.IPersonAttributeDao#getPossibleUserAttributeNames()]]>
      </doc>
    </method>
    <method name="getCacheKey" return="java.io.Serializable"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="querySeed" type="java.util.Map"/>
      <doc>
      <![CDATA[Generates a Serializable cache key from the seed parameters according to the documentation
 of this class. If the return value is NULL caching will be disabled for this query.
 
 @param querySeed The query to base the key on.
 @return A Serializable cache key.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A configurable caching implementation of {@link IPersonAttributeDao} 
 which caches results from a wrapped IPersonAttributeDao. 
 <br>
 <br>
 Configuration:
 <table border="1">
     <tr>
         <th align="left">Property</th>
         <th align="left">Description</th>
         <th align="left">Required</th>
         <th align="left">Default</th>
     </tr>
     <tr>
         <td align="right" valign="top">cachedPersonAttributesDao</td>
         <td>
             The {@link org.jasig.portal.services.persondir.IPersonAttributeDao} to delegate
             queries to on cache misses.
         </td>
         <td valign="top">Yes</td>
         <td valign="top">null</td>
     </tr>
     <tr>
         <td align="right" valign="top">userInfoCache</td>
         <td>
             The {@link java.util.Map} to use for result caching. This class does no cache
             maintenence. It is assumed the underlying Map implementation will ensure the cache
             is in a good state at all times.
         </td>
         <td valign="top">Yes</td>
         <td valign="top">null</td>
     </tr>
     <tr>
         <td align="right" valign="top">cacheKeyAttributes</td>
         <td>
             A Set of attribute names to use when building the cache key. The default
             implementation generates the key as a Map of attributeNames to values retrieved
             from the seed for the query. Zero length sets are treaded as null.
         </td>
         <td valign="top">No</td>
         <td valign="top">null</td>
     </tr>
 </table>
 
 
 @author dgrimwood@unicon.net
 @author Eric Dalquist <a href="mailto:edalquist@unicon.net">edalquist@unicon.net</a>
 @version $Id]]>
    </doc>
  </class>
  <!-- end class org.jasig.portal.services.persondir.support.CachingPersonAttributeDaoImpl -->
  <!-- start class org.jasig.portal.services.persondir.support.CascadingPersonAttributeDao -->
  <class name="CascadingPersonAttributeDao" extends="org.jasig.portal.services.persondir.support.AbstractAggregatingDefaultQueryPersonAttributeDao"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="CascadingPersonAttributeDao"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getAttributesFromDao" return="java.util.Map"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="seed" type="java.util.Map"/>
      <param name="isFirstQuery" type="boolean"/>
      <param name="currentlyConsidering" type="org.jasig.portal.services.persondir.IPersonAttributeDao"/>
      <param name="resultAttributes" type="java.util.Map"/>
      <doc>
      <![CDATA[If this is the first call, isFirstQuery == true, the query run against the current IPersonAttributeDao is done using
 the seed Map. Otherwise the query is run using the resultAttributes Map. 
 
 @see org.jasig.portal.services.persondir.support.AbstractAggregatingDefaultQueryPersonAttributeDao#getAttributesFromDao(java.util.Map, boolean, org.jasig.portal.services.persondir.IPersonAttributeDao, java.util.Map)]]>
      </doc>
    </method>
    <doc>
    <![CDATA[This {@link org.jasig.portal.services.persondir.IPersonAttributeDao}
 implementation iterates through an ordered {@link java.util.List} of
 {@link org.jasig.portal.services.persondir.IPersonAttributeDao} impls
 when getting user attributes.
 <br>
 The first DAO is queried using the seed {@link Map} passed to this class. The results
 of the query are merged into a general result map. After the first DAO this general
 result map used as the query seed for each DAO and each DAOs results are merged into it.
 <br>
 This behavior allows a DAO lower on the list to rely on attributes returned by a DAO
 higher on the list.
 <br>
 The default merger for the general result set is {@link ReplacingAttributeAdder}.
 <br>
 Note that most DAOs expect a Map of String->String. Some of the DAOs return a Map of
 String->Object or String->List. This may cause problems in the DAO if the key for an
 attribute with a non String value matches a key needed by the DAO for the query it is
 running.
 <br>
 It is <u>highly</u> recomended that the first DAO on the list for this class is
 the {@link org.jasig.portal.services.persondir.support.EchoPersonAttributeDaoImpl}
 to ensure the seed gets placed into the general result map.
 
 @author Eric Dalquist <a href="mailto:edalquist@unicon.net">edalquist@unicon.net</a>
 @version $Revision$ $Date$
 @since uPortal 2.5]]>
    </doc>
  </class>
  <!-- end class org.jasig.portal.services.persondir.support.CascadingPersonAttributeDao -->
  <!-- start class org.jasig.portal.services.persondir.support.EchoPersonAttributeDaoImpl -->
  <class name="EchoPersonAttributeDaoImpl" extends="org.jasig.portal.services.persondir.support.AbstractDefaultAttributePersonAttributeDao"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="EchoPersonAttributeDaoImpl"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getUserAttributes" return="java.util.Map"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="seed" type="java.util.Map"/>
      <doc>
      <![CDATA[Returns a duplicate of the seed it is passed.
 @return a Map equal to but not the same reference as the seed.
 @see org.jasig.portal.services.persondir.IPersonAttributeDao#getUserAttributes(java.util.Map)]]>
      </doc>
    </method>
    <method name="getPossibleUserAttributeNames" return="java.util.Set"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Possible attributes are unknown; will always return <code>null</code>.
 @return null
 @see org.jasig.portal.services.persondir.IPersonAttributeDao#getPossibleUserAttributeNames()]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Simply returns the seed it is passed.
 
 @author Eric Dalquist <a href="mailto:edalquist@unicon.net">edalquist@unicon.net</a>
 @version $Revision$ $Date$
 @since uPortal 2.5]]>
    </doc>
  </class>
  <!-- end class org.jasig.portal.services.persondir.support.EchoPersonAttributeDaoImpl -->
  <!-- start class org.jasig.portal.services.persondir.support.JdbcPersonAttributeDaoImpl -->
  <class name="JdbcPersonAttributeDaoImpl" extends="org.jasig.portal.services.persondir.support.AbstractJdbcPersonAttributeDao"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="JdbcPersonAttributeDaoImpl" type="javax.sql.DataSource, java.util.List, java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@see AbstractJdbcPersonAttributeDao#AbstractJdbcPersonAttributeDao(DataSource, List, String)]]>
      </doc>
    </constructor>
    <method name="parseAttributeMapFromResults" return="java.util.Map"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="queryResults" type="java.util.List"/>
      <doc>
      <![CDATA[Returned {@link Map} will have values of {@link String} or a
 {@link List} of {@link String}.
 
 @see org.jasig.portal.services.persondir.IPersonAttributeDao#getUserAttributes(java.util.Map)]]>
      </doc>
    </method>
    <method name="getAttributeQuery" return="org.jasig.portal.services.persondir.support.AbstractJdbcPersonAttributeDao.AbstractPersonAttributeMappingQuery"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@see org.jasig.portal.services.persondir.support.AbstractJdbcPersonAttributeDao#getAttributeQuery()]]>
      </doc>
    </method>
    <method name="getPossibleUserAttributeNames" return="java.util.Set"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getColumnsToAttributes" return="java.util.Map"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the Map from non-null String column names to Sets of non-null Strings
 representing the names of the uPortal attributes to be initialized from
 the specified column.
 @return Returns the attributeMappings mapping.]]>
      </doc>
    </method>
    <method name="setColumnsToAttributes"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="columnsToAttributesMap" type="java.util.Map"/>
      <doc>
      <![CDATA[Set the {@link Map} to use for mapping from a column name to a attribute
 name or {@link Set} of attribute names. Column names that are specified
 but have null mappings will use the column name for the attribute name.
 Column names that are not specified as keys in this {@link Map} will be
 ignored.
 <br>
 The passed {@link Map} must have keys of type {@link String} and values
 of type {@link String} or a {@link Set} of {@link String}.
 
 @param columnsToAttributesMap {@link Map} from column names to attribute names, may not be null.
 @throws IllegalArgumentException If the {@link Map} doesn't follow the rules stated above.
 @see MultivaluedPersonAttributeUtils#parseAttributeToAttributeMapping(Map)]]>
      </doc>
    </method>
    <doc>
    <![CDATA[An {@link org.jasig.portal.services.persondir.IPersonAttributeDao}
 implementation that maps from column names in the result of a SQL query
 to attribute names. <br>
 You must set a Map from column names to attribute names and only column names
 appearing as keys in that map will be used.
 <br>
 
 @author andrew.petro@yale.edu
 @author Eric Dalquist <a href="mailto:edalquist@unicon.net">edalquist@unicon.net</a>
 @version $Revision$ $Date$
 @since uPortal 2.5]]>
    </doc>
  </class>
  <!-- end class org.jasig.portal.services.persondir.support.JdbcPersonAttributeDaoImpl -->
  <!-- start class org.jasig.portal.services.persondir.support.LdapPersonAttributeDaoImpl -->
  <class name="LdapPersonAttributeDaoImpl" extends="org.jasig.portal.services.persondir.support.AbstractQueryPersonAttributeDao"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="LdapPersonAttributeDaoImpl"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getUserAttributesIfNeeded" return="java.util.Map"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="args" type="java.lang.Object[]"/>
      <doc>
      <![CDATA[Checks for valid query and context source objects.<br>
 Executes the search.<br>
 Returns the attribute map results from the query.<br>
 
 @see org.jasig.portal.services.persondir.support.AbstractQueryPersonAttributeDao#getUserAttributesIfNeeded(java.lang.Object[])]]>
      </doc>
    </method>
    <method name="getPossibleUserAttributeNames" return="java.util.Set"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getLdapAttributesToPortalAttributes" return="java.util.Map"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the mapping from LDAP attribute names to uPortal attribute names.
 Mapping type is from String to [String | Set of String].
 
 @return Returns the ldapAttributesToPortalAttributes.]]>
      </doc>
    </method>
    <method name="setLdapAttributesToPortalAttributes"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="ldapAttributesToPortalAttributesArg" type="java.util.Map"/>
      <doc>
      <![CDATA[Set the {@link Map} to use for mapping from a ldap attribute name to a
 portal attribute name or {@link Set} of portal attribute names. Ldap
 attribute names that are specified but have null mappings will use the
 ldap attribute name for the portal attribute name. Ldap attribute names
 that are not specified as keys in this {@link Map} will be ignored. <br>
 The passed {@link Map} must have keys of type {@link String} and values
 of type {@link String} or a {@link Set} of {@link String}.
 
 @param ldapAttributesToPortalAttributesArg
            {@link Map} from ldap attribute names to portal attribute
            names.
 @throws IllegalArgumentException
             If the {@link Map} doesn't follow the rules stated above.
 @see MultivaluedPersonAttributeUtils#parseAttributeToAttributeMapping(Map)]]>
      </doc>
    </method>
    <method name="getTimeLimit" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return Returns the timeLimit.]]>
      </doc>
    </method>
    <method name="setTimeLimit"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="timeLimit" type="int"/>
      <doc>
      <![CDATA[@param timeLimit The timeLimit to set.]]>
      </doc>
    </method>
    <method name="getQuery" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return Returns the query.]]>
      </doc>
    </method>
    <method name="setQuery"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="uidQuery" type="java.lang.String"/>
      <doc>
      <![CDATA[@param uidQuery The query to set.]]>
      </doc>
    </method>
    <method name="getBaseDN" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return Returns the ldapServer.]]>
      </doc>
    </method>
    <method name="setBaseDN"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="baseDN" type="java.lang.String"/>
      <doc>
      <![CDATA[@param baseDN The ldapServer to set.]]>
      </doc>
    </method>
    <method name="getContextSource" return="ContextSource"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return Returns the contextSource.]]>
      </doc>
    </method>
    <method name="setContextSource"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="contextSource" type="ContextSource"/>
      <doc>
      <![CDATA[@param contextSource The contextSource to set.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[LDAP implementation of {@link org.jasig.portal.services.persondir.IPersonAttributeDao}. This is code copied from
 uPortal 2.4 org.jasig.portal.services.PersonDirectory and made to
 implement this DAO interface. Dependent upon JNDI.
 
 In the case of multi valued attributes, now stores a
 {@link java.util.ArrayList} rather than a {@link java.util.Vector}.
 
 @author andrew.petro@yale.edu
 @author Eric Dalquist <a href="mailto:edalquist@unicon.net">edalquist@unicon.net</a>
 @version $Revision$ $Date$
 @since uPortal 2.5]]>
    </doc>
  </class>
  <!-- end class org.jasig.portal.services.persondir.support.LdapPersonAttributeDaoImpl -->
  <!-- start class org.jasig.portal.services.persondir.support.MergingPersonAttributeDaoImpl -->
  <class name="MergingPersonAttributeDaoImpl" extends="org.jasig.portal.services.persondir.support.AbstractAggregatingDefaultQueryPersonAttributeDao"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="MergingPersonAttributeDaoImpl"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getAttributesFromDao" return="java.util.Map"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="seed" type="java.util.Map"/>
      <param name="isFirstQuery" type="boolean"/>
      <param name="currentlyConsidering" type="org.jasig.portal.services.persondir.IPersonAttributeDao"/>
      <param name="resultAttributes" type="java.util.Map"/>
      <doc>
      <![CDATA[Calls the current IPersonAttributeDao from using the seed.
 
 @see org.jasig.portal.services.persondir.support.AbstractAggregatingDefaultQueryPersonAttributeDao#getAttributesFromDao(java.util.Map, boolean, org.jasig.portal.services.persondir.IPersonAttributeDao, java.util.Map)]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A {@link IPersonAttributeDao} implementation which iterates over children 
 IPersonAttributeDaos queries each with the same data and merges their
 reported attributes in a configurable way. The default merger is
 {@link MultivaluedAttributeMerger}.
 
 @author andrew.petro@yale.edu
 @author Eric Dalquist <a href="mailto:edalquist@unicon.net">edalquist@unicon.net</a>
 @version $Revision$ $Date$
 @since uPortal 2.5]]>
    </doc>
  </class>
  <!-- end class org.jasig.portal.services.persondir.support.MergingPersonAttributeDaoImpl -->
  <!-- start class org.jasig.portal.services.persondir.support.MultiRowJdbcPersonAttributeDao -->
  <class name="MultiRowJdbcPersonAttributeDao" extends="org.jasig.portal.services.persondir.support.AbstractJdbcPersonAttributeDao"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="MultiRowJdbcPersonAttributeDao" type="javax.sql.DataSource, java.util.List, java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@see AbstractJdbcPersonAttributeDao#AbstractJdbcPersonAttributeDao(DataSource, List, String)]]>
      </doc>
    </constructor>
    <method name="parseAttributeMapFromResults" return="java.util.Map"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="queryResults" type="java.util.List"/>
      <doc>
      <![CDATA[Returned {@link Map} will have values of {@link String} or a
 {@link List} of {@link String}.
 
 @see org.jasig.portal.services.persondir.IPersonAttributeDao#getUserAttributes(java.util.Map)]]>
      </doc>
    </method>
    <method name="getAttributeQuery" return="org.jasig.portal.services.persondir.support.AbstractJdbcPersonAttributeDao.AbstractPersonAttributeMappingQuery"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@see org.jasig.portal.services.persondir.support.AbstractJdbcPersonAttributeDao#getAttributeQuery()]]>
      </doc>
    </method>
    <method name="getPossibleUserAttributeNames" return="java.util.Set"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getAttributeNameMappings" return="java.util.Map"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the Map from non-null String column names to Sets of non-null Strings
 representing the names of the uPortal attributes to be initialized from
 the specified column.
 @return Returns the attributeMappings mapping.]]>
      </doc>
    </method>
    <method name="setAttributeNameMappings"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="attributeNameMap" type="java.util.Map"/>
      <doc>
      <![CDATA[TODO
 <br>
 The passed {@link Map} must have keys of type {@link String} and values
 of type {@link String} or a {@link Set} of {@link String}.
 
 @param attributeNameMap {@link Map} from column names to attribute names, may not be null.
 @throws IllegalArgumentException If the {@link Map} doesn't follow the rules stated above.
 @see MultivaluedPersonAttributeUtils#parseAttributeToAttributeMapping(Map)]]>
      </doc>
    </method>
    <method name="getNameValueColumnMappings" return="java.util.Map"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setNameValueColumnMappings"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="nameValueColumnMap" type="java.util.Map"/>
    </method>
    <doc>
    <![CDATA[An {@link org.jasig.portal.services.persondir.IPersonAttributeDao}
 implementation that maps attribute names and values from name and value column
 pairs. <br>
 
 This class expects 1-N row results for a query, with each row containing 1-N name
 value attribute mappings. This contrasts {@link org.jasig.portal.services.persondir.support.JdbcPersonAttributeDaoImpl}
 which expects a single row result for a user query. <br>
 
<br>
 <br>
 Configuration:
 <table border="1">
     <tr>
         <th align="left">Property</th>
         <th align="left">Description</th>
         <th align="left">Required</th>
         <th align="left">Default</th>
     </tr>
     <tr>
         <td align="right" valign="top">attributeNameMappings</td>
         <td>
             Maps attribute names as defined in the database to attribute names to be exposed
             to the client code. The keys of the Map must be Strings, the values may be
             <code>null</code>, String or a Set of Strings. The keySet of this Map is returned
             as  
         </td>
         <td valign="top">Yes</td>
         <td valign="top">{@link java.util.Collections#EMPTY_MAP}</td>
     </tr>
     <tr>
         <td align="right" valign="top">userInfoCache</td>
         <td>
             The {@link java.util.Map} to use for result caching. This class does no cache
             maintenence. It is assumed the underlying Map implementation will ensure the cache
             is in a good state at all times.
         </td>
         <td valign="top">Yes</td>
         <td valign="top">null</td>
     </tr>
     <tr>
         <td align="right" valign="top">cacheKeyAttributes</td>
         <td>
             A Set of attribute names to use when building the cache key. The default
             implementation generates the key as a Map of attributeNames to values retrieved
             from the seed for the query. Zero length sets are treaded as null.
         </td>
         <td valign="top">No</td>
         <td valign="top">null</td>
     </tr>
 </table>
 
 @author andrew.petro@yale.edu
 @author Eric Dalquist <a href="mailto:edalquist@unicon.net">edalquist@unicon.net</a>
 @version $Revision$ $Date$
 @since uPortal 2.5]]>
    </doc>
  </class>
  <!-- end class org.jasig.portal.services.persondir.support.MultiRowJdbcPersonAttributeDao -->
  <!-- start class org.jasig.portal.services.persondir.support.MultivaluedPersonAttributeUtils -->
  <class name="MultivaluedPersonAttributeUtils" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="parseAttributeToAttributeMapping" return="java.util.Map"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="mapping" type="java.util.Map"/>
      <doc>
      <![CDATA[Translate from a more flexible Attribute to Attribute mapping format to a Map
 from String to Set of Strings.
 
 The point of the map is to map from attribute names in the underlying data store
 (e.g., JDBC column names, LDAP attribute names) to uPortal attribute names. 
 Any given underlying data store attribute might map to zero uPortal
 attributes (not appear in the map at all), map to exactly one uPortal attribute
 (appear in the Map as a mapping from a String to a String or as a mapping
 from a String to a Set containing just one String), or map to several uPortal
 attribute names (appear in the Map as a mapping from a String to a Set
 of Strings).
 
 This method takes as its argument a {@link Map} that must have keys of 
 type {@link String} and values of type {@link String} or {@link Set} of 
 {@link String}s.  The argument must not be null and must have no null
 keys.  It must contain no keys other than Strings and no values other
 than Strings or Sets of Strings.  This method will throw
 IllegalArgumentException if the method argument doesn't meet these 
 requirements.
 
 This method returns a Map equivalent to its argument except whereever there
 was a String value in the Map there will instead be an immutable Set containing
 the String value.  That is, the return value is normalized to be a Map from
 String to Set (of String).
 
 @param mapping {@link Map} from String names of attributes in the underlying store 
 to uP attribute names or Sets of such names.
 @return a Map from String to Set of Strings
 @throws IllegalArgumentException If the {@link Map} doesn't follow the rules stated above.]]>
      </doc>
    </method>
    <method name="addResult"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="results" type="java.util.Map"/>
      <param name="key" type="java.lang.Object"/>
      <param name="value" type="java.lang.Object"/>
      <doc>
      <![CDATA[Adds a key/value pair to the specified {@link Map}, creating multi-valued
 values when appropriate.
 <br>
 Since multi-valued attributes end up with a value of type
 {@link List}, passing in a {@link List} of any type will
 cause its contents to be added to the <code>results</code>
 {@link Map} directly under the specified <code>key</code>
 
 @param results The {@link Map} to modify.
 @param key The key to add the value for.
 @param value The value to add for the key.
 @throws IllegalArgumentException if any argument is null]]>
      </doc>
    </method>
    <method name="flattenCollection" return="java.util.Collection"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="source" type="java.util.Collection"/>
      <doc>
      <![CDATA[Takes a {@link Collection} and creates a flattened {@link Collection} out
 of it.
 
 @param source The {@link Collection} to flatten.
 @return A flattened {@link Collection} that contains all entries from all levels of <code>source</code>.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[@author Eric Dalquist <a href="mailto:edalquist@unicon.net">edalquist@unicon.net</a>
 @version $Revision$ $Date$
 @since uPortal 2.5]]>
    </doc>
  </class>
  <!-- end class org.jasig.portal.services.persondir.support.MultivaluedPersonAttributeUtils -->
  <!-- start class org.jasig.portal.services.persondir.support.StubPersonAttributeDao -->
  <class name="StubPersonAttributeDao" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.jasig.portal.services.persondir.IPersonAttributeDao"/>
    <constructor name="StubPersonAttributeDao"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="StubPersonAttributeDao" type="java.util.Map"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getPossibleUserAttributeNames" return="java.util.Set"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getUserAttributes" return="java.util.Map"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="seed" type="java.util.Map"/>
    </method>
    <method name="getUserAttributes" return="java.util.Map"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="uid" type="java.lang.String"/>
    </method>
    <method name="getBackingMap" return="java.util.Map"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the Map which this stub object will return for all legal invocations of
 attributesForUser()
 
 @return Returns the backingMap.]]>
      </doc>
    </method>
    <method name="setBackingMap"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="backingMap" type="java.util.Map"/>
      <doc>
      <![CDATA[Set the Map which this stub object will return for all legal invocations of
 attributesForUser().
 
 @param backingMap The backingMap to set, may not be null.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A stub IPersonAttributeDao to be used for testing.
 Backed by a single Map which this implementation will always return.
 
 @author andrew.petro@yale.edu
 @version $Revision$ $Date$
 @since uPortal 2.5]]>
    </doc>
  </class>
  <!-- end class org.jasig.portal.services.persondir.support.StubPersonAttributeDao -->
</package>
<package name="org.jasig.portal.services.persondir.support.ldap">
  <!-- start class org.jasig.portal.services.persondir.support.ldap.PersonAttributesMapper -->
  <class name="PersonAttributesMapper" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="PersonAttributesMapper" type="java.util.Map"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Create a mapper with the ldap to portal attribute mappings. Please read the
 documentation for {@link org.jasig.portal.services.persondir.support.LdapPersonAttributeDaoImpl#setLdapAttributesToPortalAttributes(Map)}
 
 @param ldapAttributesToPortalAttributes Map of ldap to portal attributes.
 @see org.jasig.portal.services.persondir.support.LdapPersonAttributeDaoImpl#setLdapAttributesToPortalAttributes(Map)]]>
      </doc>
    </constructor>
    <method name="getLdapAttributesToPortalAttributes" return="java.util.Map"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return Returns the ldapAttributesToPortalAttributes.]]>
      </doc>
    </method>
    <method name="mapFromAttributes" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="attributes" type="javax.naming.directory.Attributes"/>
      <exception name="NamingException" type="javax.naming.NamingException"/>
      <doc>
      <![CDATA[Performs mapping after an LDAP query for a set of user attributes. Takes each key in the ldap
 to portal attribute Map and tries to find it in the returned Attributes set. For each found
 Attribute the value is added to the attribute Map as the value or in the value Set with the
 portal attribute name as the key. String and byte[] may be values.
 
 @see net.sf.ldaptemplate.AttributesMapper#mapFromAttributes(javax.naming.directory.Attributes)]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Provides {@link net.sf.ldaptemplate.AttributesMapper} for use with a {@link net.sf.ldaptemplate.LdapTemplate}
 to parse ldap query results into the person attribute Map format.
 
 @author Eric Dalquist <a href="mailto:eric.dalquist@doit.wisc.edu">eric.dalquist@doit.wisc.edu</a>
 @version $Revision$]]>
    </doc>
  </class>
  <!-- end class org.jasig.portal.services.persondir.support.ldap.PersonAttributesMapper -->
  <!-- start class org.jasig.portal.services.persondir.support.ldap.QuerySearchExecutor -->
  <class name="QuerySearchExecutor" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="QuerySearchExecutor" type="java.lang.String, java.lang.String, java.lang.Object[], javax.naming.directory.SearchControls"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a new query search executor with the parameters for the call to 
 {@link javax.naming.directory.DirContext#search(java.lang.String, java.lang.String, java.lang.Object[], javax.naming.directory.SearchControls)}]]>
      </doc>
    </constructor>
    <method name="executeSearch" return="javax.naming.NamingEnumeration"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="ctx" type="javax.naming.directory.DirContext"/>
      <exception name="NamingException" type="javax.naming.NamingException"/>
      <doc>
      <![CDATA[@see javax.naming.directory.DirContext#search(java.lang.String, java.lang.String, java.lang.Object[], javax.naming.directory.SearchControls)
 @see net.sf.ldaptemplate.SearchExecutor#executeSearch(javax.naming.directory.DirContext)]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Executes a LDAP search using the {@link javax.naming.directory.DirContext#search(java.lang.String, java.lang.String, java.lang.Object[], javax.naming.directory.SearchControls)}
 method.
 
 @author Eric Dalquist <a href="mailto:eric.dalquist@doit.wisc.edu">eric.dalquist@doit.wisc.edu</a>
 @version $Revision$]]>
    </doc>
  </class>
  <!-- end class org.jasig.portal.services.persondir.support.ldap.QuerySearchExecutor -->
</package>
<package name="org.jasig.portal.services.persondir.support.merger">
  <!-- start interface org.jasig.portal.services.persondir.support.merger.IAttributeMerger -->
  <interface name="IAttributeMerger"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="mergeAttributes" return="java.util.Map"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="toModify" type="java.util.Map"/>
      <param name="toConsider" type="java.util.Map"/>
      <doc>
      <![CDATA[Modify the "toModify" argument in consideration of the "toConsider" 
 argument.  Return the resulting Map, which may or may not be the same
 reference as the "toModify" argument.
 The modification performed is implementation-specific -- implementations
 of this interface exist to perform some particular transformation on
 the toModify argument given the toConsider argument.
 @param toModify - modify this map
 @param toConsider - in consideration of this map
 @return the modified Map
 @throws IllegalArgumentException if either toModify or toConsider is null]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Interface for merging attributes from sibling PersonAttributeDaos. 
 @author andrew.petro@yale.edu
 @version $Revision$ $Date$]]>
    </doc>
  </interface>
  <!-- end interface org.jasig.portal.services.persondir.support.merger.IAttributeMerger -->
  <!-- start class org.jasig.portal.services.persondir.support.merger.MultivaluedAttributeMerger -->
  <class name="MultivaluedAttributeMerger" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.jasig.portal.services.persondir.support.merger.IAttributeMerger"/>
    <constructor name="MultivaluedAttributeMerger"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="mergeAttributes" return="java.util.Map"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="dest" type="java.util.Map"/>
      <param name="source" type="java.util.Map"/>
      <doc>
      <![CDATA[Please note that the <code>dest</code> map is modified.
 
 @see org.jasig.portal.services.persondir.support.merger.IAttributeMerger#mergeAttributes(java.util.Map, java.util.Map)]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Merger that retains values from both maps. If a value exists for
 a key in both maps the following is done:
 <ul>
  <li>If both maps have a {@link List} they are merged into a single {@link List}</li>
  <li>If one map has a {@link List} and the other a single value the value is added to the {@link List}</li>
  <li>If both maps have a single value a {@link List} is created from the two.</li>
 </ul>
 
 @author Eric Dalquist <a href="mailto:edalquist@unicon.net">edalquist@unicon.net</a>
 @version $Revision$ $Date$]]>
    </doc>
  </class>
  <!-- end class org.jasig.portal.services.persondir.support.merger.MultivaluedAttributeMerger -->
  <!-- start class org.jasig.portal.services.persondir.support.merger.NoncollidingAttributeAdder -->
  <class name="NoncollidingAttributeAdder" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.jasig.portal.services.persondir.support.merger.IAttributeMerger"/>
    <constructor name="NoncollidingAttributeAdder"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="mergeAttributes" return="java.util.Map"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="toModify" type="java.util.Map"/>
      <param name="toConsider" type="java.util.Map"/>
      <doc>
      <![CDATA[For entries in toConsider the keys of which are not keys in toModify, 
 adds the entry to toModify and returns toModify.
 @param toModify - base Map the entries of which are considered here
 to be immutable.
 @param toConsider - Map to merge into toModify for all noncolliding keys.
 @return toModify with entries the intersection of our method arguments,
 with preference given to toModify's existing entries for all key collisions.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Merger which implements accumulation of Map entries such that entries once
 established are individually immutable.
 @author andrew.petro@yale.edu
 @version $Revision$ $Date$]]>
    </doc>
  </class>
  <!-- end class org.jasig.portal.services.persondir.support.merger.NoncollidingAttributeAdder -->
  <!-- start class org.jasig.portal.services.persondir.support.merger.ReplacingAttributeAdder -->
  <class name="ReplacingAttributeAdder" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.jasig.portal.services.persondir.support.merger.IAttributeMerger"/>
    <constructor name="ReplacingAttributeAdder"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="mergeAttributes" return="java.util.Map"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="toModify" type="java.util.Map"/>
      <param name="toConsider" type="java.util.Map"/>
      <doc>
      <![CDATA[Simply puts all the values in toConsider into toModify and returns toModify.
 This means that for keys in both toConsider and toModify, the
 value in toConsider will be controlling.
 @param toModify - the Map we are to modify
 @param toConsider - the Map we are to consider in modifying toModify
 @return the result of toModify.putAll(toConsider)]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Attribute merge strategy whereby considered attributes over-write
 previously set values for attributes with colliding names.
 @author andrew.petro@yale.edu
 @version $Revision$ $Date$]]>
    </doc>
  </class>
  <!-- end class org.jasig.portal.services.persondir.support.merger.ReplacingAttributeAdder -->
</package>

</api>
